## Chapter 8: Main Memory

### 8.1.3 Logical Versus Physical Address Space

- An address generated by the CPU is referred to as a **logical address**.
- An address seen by the memory unit (the one loaded into the memory-address register) is the **physical address**.
- The execution-time address-binding scheme results in logical and physical addresses that differ.
    - In this scheme, the logical address is often called a **virtual address** (the terms are used interchangeably).
    - The **logical address space** is the set of all logical addresses generated by a program.
    - The **physical address space** is the set of all physical addresses corresponding to those logical addresses.
- The run-time mapping from virtual to physical addresses is handled by a hardware device called the **memory-management unit (MMU)**.
- A simple MMU scheme generalizes the base-register approach, using a **relocation register**.
    - The value in the relocation register is **added to every address generated by a user process** when the address is sent to memory. For instance, if the base is 14000, an access to logical address 346 is mapped to physical address 14346.
- The concept of a logical address space bound to a separate physical address space is central to proper memory management.

---

### 8.2 Swapping

- A process must be in memory to be executed. **Swapping** allows a process to be **temporarily moved out of memory to a backing store** and later returned to memory for continued execution.
- Swapping enables the total physical address space of all processes to exceed the real physical memory size, thereby increasing the **degree of multiprogramming**.

#### 8.2.1 Standard Swapping

- Standard swapping involves moving processes between main memory and a **backing store** (typically a fast disk).
- The backing store must be large enough to hold copies of all memory images for all users and must provide direct access to these images.
- The system maintains a **ready queue** of all processes ready to run, whether they are on the backing store or already in memory.
- When the CPU scheduler selects a process, the dispatcher checks if it is in memory. If it is not, and if there is no free memory, the dispatcher swaps out a process currently in memory and **swaps in the desired process**.
- Standard swapping is **not used in modern operating systems** because it requires too much time for swapping relative to execution time.
- Modified versions of swapping exist in systems like UNIX, Linux, and Windows, often only starting when the amount of free memory falls below a threshold, or by swapping only portions of processes instead of the entire process.

#### 8.2.2 Swapping on Mobile Systems

- Mobile systems, such as iOS and Android, typically **do not support swapping**.
- This avoidance is due to factors like space constraints (using flash memory instead of hard disks), the limited number of writes flash memory can tolerate, and poor throughput between main memory and flash memory.
- Mobile systems generally support paging.

---

### 8.3 Contiguous Memory Allocation

- **Contiguous memory allocation** is an early method where **each process is contained in a single, contiguous section of memory**.
- Memory is usually partitioned into sections for the resident operating system (often in low memory) and user processes.

#### 8.3.1 Memory Protection

- Protection is achieved using a **relocation register** (holding the smallest legal physical address) and a **limit register** (containing the range of logical addresses).
- The MMU maps the logical address dynamically by adding the relocation register value, and the hardware checks that the logical address falls within the range specified by the limit register.

#### 8.3.2 Memory Allocation

- One method involves dividing memory into **fixed-sized partitions**, where the degree of multiprogramming is fixed by the number of partitions (an old method, historically used by IBM OS/360 MFT).
- A generalization involves solving the **dynamic storage-allocation problem**: satisfying a request of size $n$ from a list of free memory regions ("holes"). Common strategies include:
    - **First fit:** Allocate the first hole found that is big enough.
    - **Best fit:** Allocate the smallest hole that is sufficiently large.
    - **Worst fit:** Allocate the largest hole.

#### 8.3.3 Fragmentation

- Both first-fit and best-fit strategies suffer from **external fragmentation**, where there is enough total memory space to satisfy a request, but the available spaces are not contiguous.
- **Compaction** is one solution to external fragmentation; it shuffles memory contents to bring all free memory together into one large block.
- Compaction is only possible if relocation is **dynamic** (done at execution time).
- Another solution is to allow the logical address space to be **noncontiguous**, accomplished using segmentation or paging.

---

### 8.4 Segmentation

- **Segmentation** is a memory-management scheme that allows the physical address space of a process to be **noncontiguous** and supports the programmer's view of memory.
- Programmers view memory as a collection of **variable-sized segments** (e.g., main program, stack, data structures).
- A logical address space in segmentation is a collection of segments.
- A logical address consists of a two-tuple: **<segment-number, offset>**.

#### 8.4.2 Segmentation Hardware

- Segmentation uses a **segment table** to map two-dimensional logical addresses to one-dimensional physical addresses.
- Each segment table entry includes a **segment base** (starting physical address) and a **segment limit** (length of the segment).
- Address translation checks that the offset ($d$) is within the limit ($0$ to $\text{limit}$). If valid, the offset is added to the segment base to find the physical memory address. If invalid, a trap to the operating system occurs.

---

### 8.5 Paging

- **Paging** is a memory-management scheme that enables a process's physical address space to be **noncontiguous**, avoiding external fragmentation and the need for compaction.
- Paging is implemented through cooperation between the operating system and hardware and is widely used in most operating systems.

#### 8.5.1 Basic Method

- Physical memory is divided into fixed-sized blocks called **frames**.
- Logical memory is divided into blocks of the same size called **pages**.
- A process's pages are loaded into any available frames.
- A logical address is divided into a **page number (p)** and a **page offset (d)**.
- The page number is used as an index into the **page table**, which contains the base address (or frame number, $f$) of each page in physical memory.
- The physical memory address is defined by combining the frame number ($f$) from the page table with the page offset ($d$).
- Page size is a **power of 2** (e.g., 512 bytes to 1 GB, but typically 4 KB to 8 KB today), simplifying the translation of logical addresses into page numbers and offsets.
- The operating system maintains a **frame table** to track physical memory allocation details, such as which frames are free or allocated.
- Internal fragmentation is expected to average one-half page per process.

#### 8.5.2 Hardware Support

- A pointer to the page table is stored in the process control block (PCB).
- To accelerate address translation, a specialized, small, fast-lookup hardware cache called a **translation look-aside buffer (TLB)** is used.
- The TLB is associative, high-speed memory. Each entry contains a key (virtual page number) and a value (frame number).
- A TLB is typically small (32 to 1,024 entries).
- In the event of a TLB miss, the system must consult the page table, which usually resides in main memory.
- Some TLBs allow certain entries, typically for key kernel code, to be **wired down**, meaning they cannot be removed.