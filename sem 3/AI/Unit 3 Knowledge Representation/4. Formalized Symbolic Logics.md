### 4.1 Introduction (p. 47)

- **Symbolic Logic** predates modern computers, but its practical application in representing and manipulating knowledge via computers was first demonstrated in the early 1960s (Gilmore, 1960).
- **First Order Predicate Logic (FOPL)**, also called Predicate Calculus, has become one of the most vital representation methods in AI.
- **Importance of FOPL:**
    1. **Sound Theoretical Foundation:** Logic provides the only formal approach to reasoning that has a sound theoretical basis, ensuring automated inferences are logically correct.
    2. **Expressiveness:** The structure of FOPL is flexible enough to accurately represent natural language reasonably well, which is essential for AI systems.
    3. **Widespread Acceptance:** FOPL is widely accepted in the AI field as a useful representation method, frequently used in program designs and literature.
- **Automated Reasoning (Inferencing):** Logic is a **formal method for reasoning** where statements (like English sentences) are translated into symbolic structures. These structures are manipulated by **inference rules** to transform "assumed" facts into new "deduced" structures.
- FOPL structures are composed of **predicates, functions, variables, constants, quantifiers**, and **logical connectives**.
- The chapter first introduces **Propositional Logic (PL)**, a special case of FOPL, as many concepts applicable to PL extend to FOPL.

### 4.2 Syntax and Semantics for Propositional Logic (p. 49)

#### Syntax

- **Propositions** are elementary atomic sentences that must be either **true** or **false**.
- **Compound propositions** are formed from atomic formulas using logical connectives.
- **Logical Connective Symbols:**
    - $\neg$ (not or negation)
    - $\land$ (and or conjunction)
    - $\lor$ (or or disjunction, inclusive)
    - $\to$ (if... then or implication)
    - $\leftrightarrow$ (if and only if or double implication)
- **Formulas (wffs):** $T$ (true) and $F$ (false) are formulas. If $P$ and $Q$ are formulas, then $\neg P, (P \land Q), (P \lor Q), (P \to Q)$, and $(P \leftrightarrow Q)$ are also formulas.
- **Precedence of Connectives (Highest to Lowest):** $\neg, \land, \lor, \to, \leftrightarrow$.

#### Semantics and Properties of Statements

- **Semantics** is the assignment of a **truth value (true or false)** to a sentence.
- An **interpretation** assigns a truth value to each propositional symbol.
- **Satisfiable:** A statement is satisfiable if there is **some interpretation** for which it is true.
- **Contradiction (Unsatisfiable):** A sentence is contradictory if there is **no interpretation** for which it is true.
- **Valid (Tautology):** A statement is valid if it is true under **every interpretation**.
- **Logical Consequence:** A sentence $s$ is a logical consequence of premises $s_1, \dots, s_n$ if any interpretation that makes the conjunction of premises ($s_1 \land \dots \land s_n$) true also makes $s$ true. If this holds, $s_1 \land \dots \land s_n \to s$ is called a **theorem**.
- **Equivalence Laws** (e.g., De Morgan's laws, Conditional elimination) permit substitution of expressions without changing the truth value.

#### Inference Rules

The inference rules of PL enable logical proofs: given premises $S = {s_1, \dots, s_n}$, prove the truth of conclusion $s$ (i.e., show $S \vdash s$).

- **Modus Ponens:** From $P$ and $P \to Q$ infer $\mathbf{Q}$.
- **Chain Rule:** From $P \to Q$ and $Q \to R$ infer $\mathbf{P \to R}$.
- **Substitution:** If $s$ is valid, consistent substitution of propositions in $s$ yields another valid statement $s'$.
- **Simplification:** From $P \land Q$ infer $\mathbf{P}$.
- **Conjunction:** From $P$ and $Q$ infer $\mathbf{P \land Q}$.
- **Transposition:** From $P \to Q$ infer $\mathbf{\neg Q \to \neg P}$.
- **Formal System:** A set of axioms $S$ and a set of inference rules $L$, sometimes denoted $<S, L>$ or **KB** (knowledge base).
- **Soundness:** Inference procedure $L$ is **sound** if every derivable statement $s$ is a logical consequence of $<S, L>$.
- **Completeness:** Inference procedure $L$ is **complete** if every sentence $s$ logically implied by $<S, L>$ can be derived using $L$.

### 4.3 Syntax and Semantics for FOPL (p. 55)

FOPL is a generalization of PL that allows reasoning about **world objects** as relational entities and classes of objects, providing greater expressiveness.

#### Syntax of FOPL

- **Terms:** Constants, variables, and functions.
- **Constants:** Fixed-value terms (e.g., $a$, $5.3$, $john$).
- **Variables:** Terms that can assume different values over a domain (e.g., $x, y, z$).
- **Functions:** Denoted by symbols (e.g., $f$, $father$-$of$) mapping $n$ elements (terms) to a single domain element. A 0-ary function is a constant.
- **Predicates (Atomic Formulas/Atoms):** Symbols (e.g., $P$, MARRIED) mapping domain elements to **true** or **false**. A 0-ary predicate is a proposition.
- **Quantifiers:**
    - $\exists$ (existential quantification): "for some $x$" or "there is an $x$".
    - $\forall$ (universal quantification): "**for all** $x$".
- **Wffs:** Formed from atomic formulas, quantifiers, and logical connectives.

#### Semantics for FOPL

- **Domain (D):** The set of all elements or objects from which fixed assignments are made to constants, and over which functions and predicates are defined.
- An **interpretation** assigns values to each term (constants, variables, functions) and to each predicate symbol in a wff, allowing the truth value of the wff to be determined.

### 4.4 Properties of Wffs (p. 60)

- **Logical Consequence:** Defined the same as in PL (see 4.2).
- **Conjunctive Normal Form (CNF):** A conjunction ($\land$) of clauses, where each clause is a disjunction ($\lor$) of literals. Example: $(\neg P \lor Q \lor R) \land (\neg P \lor Q) \land R$.
- **Disjunctive Normal Form (DNF):** A disjunction ($\lor$) of terms, where each term is a conjunction ($\land$) of literals.
- Any wff can be transformed into either normal form.

### 4.5 Conversion to Clausal Form (p. 62)

**Clausal Form** is a required normalization for mechanical inference methods like resolution.

- **Clause:** The disjunction of literals.
- **Ground Clause:** A clause with no variables.
- **Horn Clause:** A clause with at most **one positive literal**.
- **Clausal Conversion Procedure Steps:**
    1. Eliminate implication ($\to$) and equivalency ($\leftrightarrow$) connectives.
    2. Move negations ($\neg$) inward to immediately precede an atom (e.g., apply DeMorgan's laws).
    3. Rename variables so all quantifiers use different assignments.
    4. **Skolemize:** Replace all existentially quantified variables ($\exists$) with **Skolem functions** or **Skolem constants**, and delete the $\exists$ quantifier.
    5. Move all universal quantifiers ($\forall$) to the left and convert the expression on the right into **CNF**.
    6. Eliminate all universal quantifiers and conjunctions (which are retained implicitly).
- The resulting set of clauses is **satisfiable if and only if** the original sentence is satisfiable (they are not necessarily equivalent).

### 4.6 Inference Rules (p. 65)

- **Modus Ponens** is a key rule in FOPL.
- **Substitution** is essential to inference, particularly for instantiating universal variables (e.g., $x$ replaced by $a$).
- **Complementary Literals** are identical atoms with opposite signs (e.g., $P$ and $\neg P$).
- **Unification:** The process of finding a substitution ($\beta$) that makes two or more expressions equal.
    - **Most General Unifier (mgu):** The most general possible unifier.
    - **Factor/Factoring:** A clause resulting from unifying two or more literals within a single original clause and deleting the redundant literals.
- The source provides a detailed **Unification Algorithm** based on finding the disagreement set of expressions.

### 4.7 The Resolution Principle (p. 66)

- **Resolution Principle:** A syntactic inference procedure that determines if a set of clauses is **unsatisfiable**.
- **Proof by Refutation:** To prove conclusion $Q$ is a logical consequence of premises $C_1, \dots, C_n$, one negates $Q$ ($\neg Q$) and adds it to the clause set. If the set is unsatisfiable, resolution yields the **empty clause** ($\Box$).
- Resolution with factoring is **complete** (it always generates $\Box$ from an unsatisfiable set).
- **Resolution Process:** Two clauses, $C_1$ and $C_2$, are combined by deleting a pair of complementary literals ($l_1 \in C_1$ and $l_2 \in C_2$), forming the **resolvent** $C$ as the disjunction of the remaining literals.
- **Types of Resolution:**
    - **Binary Resolution:** Combining two clauses with complementary literals.
    - **Unit Resulting (UR) Resolution:** Resolving multiple clauses simultaneously to produce a single literal clause (unit clause).
    - **Linear Resolution:** A sequence of resolutions where each derived clause $C_i$ is a parent to the subsequent clause $C_{i+1}$.
- **Strategy:** Because random resolution can be inefficient (combinatorial explosion), methods must constrain the search.

### 4.8 Nondeductive Inference Methods (p. 73)

These methods are not logically valid, but they are useful and frequently employed in everyday reasoning.

- **Abductive Inference:** Uses known causal knowledge to justify a conclusion (which may be invalid). Given $\mathbf{Q}$ is true and $P \to Q$, conclude $P$.
- **Inductive Inference:** Assumes an observed, recurring pattern for some instances is true for the **entire class**. Given $P(a_1), \dots, P(a_k)$, conclude $\forall x P(x)$.
- **Analogical Inference:** Concludes that if two objects $A$ and $B$ are similar in several known respects, they must be similar in another respect $P$.

### 4.9 Representations Using Rules (p. 75)

- Rules are a **subset of predicate logic** and are a popular representation scheme for expert systems (rule-based systems).
- **Rule Components:**
    - **Left-Hand Side (LHS):** The antecedent, premise, condition, or situation (the **if** part).
    - **Right-Hand Side (RHS):** The consequent, conclusion, action, or response (the **then** part).
- **Rule-Based System Core:** Consists of a **knowledge base** (set of rules), a **working memory**, and a **rule interpreter** (inference engine).
- **Inference Process:** The interpreter matches the LHS of rules against working memory contents. When a rule matches, it "fires," and the RHS updates the working memory. This sequence of actions is essentially an inference process using the chain rule.
- **Confidence Factors (CF):** Numerical values (ranging from -1.0 to 1.0) sometimes attached to rules, measuring the expert's confidence in the rule's applicability.

### 4.10 Summary (p. 76)

- **FOPL** provides a **theoretically sound** basis and **great latitude of expressiveness** for knowledge representation.
- The ability to derive conclusions mechanically is achieved through **resolution**, which requires conversion to clausal normal forms.
- The three key syntactic inference methods are **Modus Ponens**, **Chain Rule**, and **Resolution**.
- **Rules** are a convenient and popular subset of FOPL often used in expert systems.
- Nondeductive (invalid but useful) inference forms include **abductive, inductive**, and **analogical** methods.